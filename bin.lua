root = "/"
root_runtime = "src"
JSON = "[{\"t\": 2, \"p\": \"src/core\"}, {\"t\": 1, \"p\": \"src/core/delete.lua\", \"c\": \"local wherecore = require(\\\"src.core.where\\\")\\nlocal tablecheck = require(\\\"src.core.tablecheck\\\")\\n\\nlocal deletecore = {}\\n\\nfunction deletecore.delete(query_serialized, db)\\n    current_table = db.opentable(query_serialized.from)\\n    if current_table == nil then\\n        print(\\\"[ERROR]: Table '\\\" .. query_serialized.from .. \\\"' does not exist.\\\")\\n        return false\\n    end\\n\\n    if query_serialized.data.where and next(query_serialized.data.where) then\\n        local where_filtered = wherecore.appy_where(query_serialized.data.where, current_table.data)\\n        results = where_filtered\\n    else\\n        results = current_table.data\\n    end\\n\\n    for _, row in ipairs(results) do\\n        local i = 0\\n        local stop = false\\n        while not stop and i < #current_table.data do\\n            i = i + 1\\n            local data = current_table.data[i]\\n            if data[\\\"?sysid?\\\"] == row[\\\"?sysid?\\\"] then\\n                table.remove(current_table.data, i)\\n            end\\n        end\\n    end\\n\\n    if not tablecheck.check_table(current_table) then\\n        print(\\\"[ERROR]: Delete operation aborted due to table constraint violations (type, not null, etc.).\\\")\\n        return false\\n    end\\n\\n    db.savetable(query_serialized.from, current_table)\\n    return {\\n        success = true,\\n        affected_rows = #results\\n    }\\nend\\n\\nreturn deletecore\\n\"}, {\"t\": 1, \"p\": \"src/core/insert.lua\", \"c\": \"local tablecheck = require(\\\"src.core.tablecheck\\\")\\nlocal parseglobals = require(\\\"src.parser.parse_globals\\\")\\n\\nlocal insertcore = {}\\n\\nfunction insertcore.insert(serialized_query, db)\\n    local table_name = serialized_query.from\\n    local current_table = db.opentable(serialized_query.from)\\n    if not current_table then\\n        print(\\\"[ERROR]: Table '\\\" .. table_name .. \\\"' does not exist.\\\")\\n        return nil\\n    end\\n\\n    local columns = serialized_query.data.columns\\n    local values = serialized_query.data.values\\n    for _, value_set in ipairs(values) do\\n        local new_row = {}\\n        for i, column in pairs(current_table.schema.fields) do\\n            local col_name = i\\n            local col_index = nil\\n            for j, col in ipairs(columns) do\\n                if col == col_name then\\n                    col_index = j\\n                    break\\n                end\\n            end\\n            if col_index then\\n                if value_set[col_index] == parseglobals.NULL then\\n                    new_row[col_name] = nil\\n                else\\n                    new_row[col_name] = value_set[col_index]\\n                end\\n            else\\n                if column.default ~= nil and column.default ~= nil then\\n                    new_row[col_name] = column.default\\n                else\\n                    local stop = false\\n                    local index = 1\\n                    while not stop and index <= #current_table.schema.indexes do\\n                        local idx = current_table.schema.indexes[index]\\n                        if idx.field == col_name and idx.type == \\\"ai\\\" then\\n                            new_row[col_name] = idx.current\\n                            idx.current = idx.current + 1\\n                            stop = true\\n                        end\\n                        index = index + 1\\n                    end\\n                end\\n            end\\n        end\\n        new_row[\\\"?sysid?\\\"] = current_table.schema.current_sysid\\n        current_table.schema.current_sysid = current_table.schema.current_sysid + 1\\n        print(\\\"[DBG]: Inserting row:\\\")\\n        table.insert(current_table.data, new_row)\\n    end\\n\\n    if not tablecheck.check_table(current_table) then\\n        print(\\\"[ERROR]: Table '\\\" ..\\n            table_name .. \\\"' integrity check failed after INSERT operation. (Rolling back changes.)\\\")\\n        return nil\\n    end\\n    db.savetable(table_name, current_table)\\n    return {\\n        success = true,\\n        affected_rows = #values\\n    }\\nend\\n\\nreturn insertcore\\n\"}, {\"t\": 1, \"p\": \"src/core/run.lua\", \"c\": \"local ccdb_parse = require(\\\"src.parser.parser\\\")\\nlocal selectcore = require(\\\"src.core.select\\\")\\nlocal insertcore = require(\\\"src.core.insert\\\")\\nlocal updatecore = require(\\\"src.core.update\\\")\\nlocal deletecore = require(\\\"src.core.delete\\\")\\nlocal runner = {}\\n\\nfunction runner.run(query, db)\\n    serialized_query = ccdb_parse.parse(query)\\n    if not serialized_query then\\n        print(\\\"[ERROR]: Unable to parse query.\\\")\\n        return nil; -- I will add error processing later\\n    end\\n    if serialized_query.type == \\\"select\\\" then\\n        return selectcore.select(serialized_query, db)\\n    elseif serialized_query.type == \\\"insert\\\" then\\n        return insertcore.insert(serialized_query, db)\\n    elseif serialized_query.type == \\\"update\\\" then\\n        return updatecore.update(serialized_query, db)\\n    elseif serialized_query.type == \\\"delete\\\" then\\n        return deletecore.delete(serialized_query, db)\\n    else\\n        print(\\\"[DBG]: Serialized query:\\\")\\n        print(textutils.serialize(serialized_query))\\n        print(\\\"[ERROR]: Query type '\\\" .. serialized_query.type .. \\\"' not supported yet.\\\")\\n        return nil; -- I will add error processing later\\n    end\\nend\\n\\nreturn runner\\n\"}, {\"t\": 1, \"p\": \"src/core/select.lua\", \"c\": \"local wherecore = require(\\\"src.core.where\\\")\\n\\nlocal selectcore = {}\\n\\nfunction selectcore.select(query_serialized, db)\\n    current_table = db.opentable(query_serialized.from)\\n    local results = {}\\n    if query_serialized.data.where and next(query_serialized.data.where) then\\n        local where_filtered = wherecore.appy_where(query_serialized.data.where, current_table.data)\\n        results = where_filtered\\n    else\\n        results = current_table.data\\n    end\\n\\n    table.sort(results, function(a, b)\\n        for _, order_rule in ipairs(query_serialized.data.order_by or {}) do\\n            local col = order_rule.column\\n            local order = order_rule.order\\n            if a[col] ~= b[col] then\\n                if order == \\\"ASC\\\" then\\n                    return a[col] < b[col]\\n                else\\n                    return a[col] > b[col]\\n                end\\n            end\\n        end\\n        return false\\n    end)\\n\\n    if query_serialized.data.limit then\\n        local limited_results = {}\\n        for i = 1, math.min(query_serialized.data.limit, #results) do\\n            table.insert(limited_results, results[i])\\n        end\\n        results = limited_results\\n    end\\n    for i, row in ipairs(results) do\\n        local filtered_row = {}\\n        for col, value in pairs(row) do\\n            if col ~= \\\"?sysid?\\\" then\\n                filtered_row[col] = value\\n            end\\n        end\\n        results[i] = filtered_row\\n    end\\n    return results\\nend\\n\\nreturn selectcore\\n\"}, {\"t\": 1, \"p\": \"src/core/tablecheck.lua\", \"c\": \"local tablecheckcore = {}\\n\\nfunction tablecheckcore.check_table(table)\\n    -- First: check for NOT NULL constraints\\n    for _, row in ipairs(table.data) do\\n        for col_name, col_schema in pairs(table.schema.fields) do\\n            if col_schema.nullable == false and (row[col_name] == nil) then\\n                print(\\\"[ERROR]: NOT NULL constraint violated for column '\\\" .. col_name .. \\\"'.\\\")\\n                return false\\n            end\\n        end\\n    end\\n    -- Second: check for TYPES\\n    for _, row in ipairs(table.data) do\\n        for col_name, col_schema in pairs(table.schema.fields) do\\n            local value = row[col_name]\\n            if value ~= nil then\\n                local value_type = col_schema.type[1]\\n\\n                if value == nil then\\n                    value_type = \\\"null\\\" -- Handle NULL case\\n                end\\n\\n                if value_type == \\\"varchar\\\" then\\n                    local max_length = col_schema.type[2]\\n                    if type(value) ~= \\\"string\\\" then\\n                        print(\\\"[ERROR]: Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected VARCHAR.\\\")\\n                        return false\\n                    end\\n                    if #value > max_length then\\n                        print(\\\"[ERROR]: Length constraint violated for column '\\\" ..\\n                            col_name .. \\\"'. Maximum length is \\\" .. max_length .. \\\".\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"int\\\" then\\n                    if type(value) ~= \\\"number\\\" or value % 1 ~= 0 then\\n                        print(\\\"[ERROR]: Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected INT.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"float\\\" then\\n                    if type(value) ~= \\\"number\\\" then\\n                        print(\\\"[ERROR]: Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected FLOAT.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"boolean\\\" then\\n                    if type(value) ~= \\\"boolean\\\" then\\n                        print(\\\"[ERROR]: Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected BOOLEAN.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"null\\\" then\\n                    if value ~= nil then\\n                        print(\\\"[ERROR]: Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected NULL.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"text\\\" then\\n                    if type(value) ~= \\\"string\\\" then\\n                        print(\\\"[ERROR]: Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected TEXT.\\\")\\n                        return false\\n                    end\\n                end\\n            end\\n        end\\n    end\\n\\n    -- Check for UNIQUE constraints (and PRIMARY KEY, which is a special case of UNIQUE)\\n\\n    for i, index_data in ipairs(table.schema.indexes) do\\n        if index_data.type == \\\"unique\\\" or index_data.type == \\\"pk\\\" then\\n            local seen_values = {}\\n            for _, row in ipairs(table.data) do\\n                local value = row[index_data.field]\\n                if value ~= nil then\\n                    if seen_values[value] then\\n                        print(\\\"[ERROR]: UNIQUE constraint violated for column '\\\" .. index_data.field .. \\\"'.\\\")\\n                        return false\\n                    else\\n                        seen_values[value] = true\\n                    end\\n                end\\n            end\\n        end\\n    end\\n    return true\\nend\\n\\nreturn tablecheckcore\\n\"}, {\"t\": 1, \"p\": \"src/core/update.lua\", \"c\": \"local wherecore = require(\\\"src.core.where\\\")\\nlocal tablecheck = require(\\\"src.core.tablecheck\\\")\\nlocal parseglobals = require(\\\"src.parser.parse_globals\\\")\\n\\nlocal updatecore = {}\\n\\nfunction updatecore.update(query_serialized, db)\\n    current_table = db.opentable(query_serialized.from)\\n    if current_table == nil then\\n        print(\\\"[ERROR]: Table '\\\" .. query_serialized.from .. \\\"' does not exist.\\\")\\n        return false\\n    end\\n\\n    if query_serialized.data.where and next(query_serialized.data.where) then\\n        local where_filtered = wherecore.appy_where(query_serialized.data.where, current_table.data)\\n        results = where_filtered\\n    else\\n        results = current_table.data\\n    end\\n\\n    for _, row in ipairs(results) do\\n        for i, data in ipairs(current_table.data) do\\n            if data[\\\"?sysid?\\\"] == row[\\\"?sysid?\\\"] then\\n                for _, set_clause in ipairs(query_serialized.data.set) do\\n                    local col_name = set_clause.column\\n                    local new_value = set_clause.value\\n                    for _, index in ipairs(current_table.schema.indexes) do\\n                        if index.field == col_name and index.type == \\\"pk\\\" then\\n                            print(\\\"[ERROR]: Cannot update PRIMARY KEY column '\\\" .. col_name .. \\\"'.\\\")\\n                            return false\\n                        end\\n                    end\\n                    if new_value == parseglobals.NULL then\\n                        new_value = nil\\n                    end\\n                    current_table.data[i][col_name] = new_value\\n                end\\n            end\\n        end\\n    end\\n\\n    if not tablecheck.check_table(current_table) then\\n        print(\\\"[ERROR]: Update operation aborted due to table constraint violations (type, not null, etc.).\\\")\\n        return false\\n    end\\n\\n    db.savetable(query_serialized.from, current_table)\\n    return {\\n        success = true,\\n        affected_rows = #results\\n    }\\nend\\n\\nreturn updatecore\\n\\n-- {\\n--     data = {\\n--         set = {\\n--             {\\n--                 value = \\\"none@none.none\\\",\\n--                 column = \\\"email\\\"\\n--             }\\n--         },\\n--         where = {\\n--             {\\n--                 column = \\\"id\\\",\\n--                 operator = \\\"=\\\",\\n--                 value = 1\\n--             }\\n--         }\\n--     },\\n--     from = \\\"users\\\",\\n--     type = \\\"update\\\"\\n-- }\\n\"}, {\"t\": 1, \"p\": \"src/core/where.lua\", \"c\": \"local wherecore = {}\\n\\nfunction wherecore.appy_where(conditions, current_table)\\n    local results = {}\\n\\n    for _, row in ipairs(current_table) do\\n        local conditions_met = {}\\n\\n        -- First evaluate all conditions, no matter the type\\n\\n        for _, condition in ipairs(conditions) do\\n            local column_value = row[condition.column]\\n            local condition_value = condition.value\\n            local operator = condition.operator\\n            local condition_met = false\\n\\n            if operator == \\\"=\\\" then\\n                condition_met = (column_value == condition_value)\\n            elseif operator == \\\"!=\\\" then\\n                condition_met = (column_value ~= condition_value)\\n            elseif operator == \\\">\\\" then\\n                condition_met = (column_value > condition_value)\\n            elseif operator == \\\"<\\\" then\\n                condition_met = (column_value < condition_value)\\n            elseif operator == \\\">=\\\" then\\n                condition_met = (column_value >= condition_value)\\n            elseif operator == \\\"<=\\\" then\\n                condition_met = (column_value <= condition_value)\\n            elseif operator == \\\"%\\\" then\\n                local pattern = condition_value:gsub(\\\"%%\\\", \\\".*\\\"):gsub(\\\"_\\\", \\\".\\\")\\n                condition_met = string.match(tostring(column_value), \\\"^\\\" .. pattern .. \\\"$\\\") ~= nil\\n            else\\n                print(\\\"[ERROR]: Unknown operator '\\\" .. operator .. \\\"' in WHERE clause.\\\")\\n            end\\n            table.insert(conditions_met, {\\n                met = condition_met,\\n                type = condition.type\\n            })\\n        end\\n\\n        local groups = {}\\n        local current_and = true\\n        local first = true\\n\\n        for i, cond in ipairs(conditions_met) do\\n            if first then\\n                current_and = cond.met\\n                first = false\\n            else\\n                if cond.type == \\\"AND\\\" then\\n                    current_and = current_and and cond.met\\n                elseif cond.type == \\\"OR\\\" then\\n                    table.insert(groups, current_and)\\n                    current_and = cond.met\\n                end\\n            end\\n        end\\n\\n        -- push last AND group\\n        table.insert(groups, current_and)\\n\\n        -- OR all groups\\n        local stop = false\\n        local i = 1\\n        while not stop and i <= #groups do\\n            if groups[i] then\\n                table.insert(results, row)\\n                stop = true\\n            end\\n            i = i + 1\\n        end\\n    end\\n    return results\\nend\\n\\nreturn wherecore\\n\"}, {\"t\": 2, \"p\": \"src/examples\"}, {\"t\": 2, \"p\": \"src/examples/db01\"}, {\"t\": 1, \"p\": \"src/examples/db01/ccdb.json\", \"c\": \"{\\n    \\\"tables\\\": {\\n        \\\"user\\\": \\\"user.json\\\"\\n    },\\n    \\\"login\\\": {\\n        \\\"username\\\": \\\"admin\\\",\\n        \\\"password\\\": \\\"admin\\\"\\n    }\\n}\"}, {\"t\": 1, \"p\": \"src/examples/db01/user.json\", \"c\": \"{\\n    \\\"schema\\\": {\\n        \\\"current_sysid\\\": 3,\\n        \\\"name\\\": \\\"user\\\",\\n        \\\"indexes\\\": [\\n            {\\n                \\\"field\\\": \\\"id\\\",\\n                \\\"type\\\": \\\"pk\\\"\\n            },\\n            {\\n                \\\"field\\\": \\\"username\\\",\\n                \\\"type\\\": \\\"unique\\\"\\n            },\\n            {\\n                \\\"field\\\": \\\"id\\\",\\n                \\\"type\\\": \\\"ai\\\",\\n                \\\"start\\\": 1,\\n                \\\"current\\\": 3\\n            }\\n        ],\\n        \\\"fields\\\": {\\n            \\\"id\\\": {\\n                \\\"type\\\": [\\n                    \\\"integer\\\"\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"username\\\": {\\n                \\\"type\\\": [\\n                    \\\"varchar\\\",\\n                    20\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"email\\\": {\\n                \\\"type\\\": [\\n                    \\\"varchar\\\",\\n                    50\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"age\\\": {\\n                \\\"type\\\": [\\n                    \\\"integer\\\"\\n                ],\\n                \\\"nullable\\\": true,\\n                \\\"default\\\": null\\n            }\\n        }\\n    },\\n    \\\"data\\\": [\\n        {\\n            \\\"?sysid?\\\": 1,\\n            \\\"id\\\": 1,\\n            \\\"username\\\": \\\"alice\\\",\\n            \\\"email\\\": \\\"alice@example.com\\\",\\n            \\\"age\\\": 30\\n        },\\n        {\\n            \\\"?sysid?\\\": 2,\\n            \\\"id\\\": 2,\\n            \\\"username\\\": \\\"Jean-Luc\\\",\\n            \\\"email\\\": \\\"jeanluc@example.com\\\",\\n            \\\"age\\\": 45\\n        }\\n    ]\\n}\"}, {\"t\": 2, \"p\": \"src/fs\"}, {\"t\": 1, \"p\": \"src/fs/dbmgr.lua\", \"c\": \"local dbmgr = {}\\n\\nfunction dbmgr.opendb(path)\\n    local db = {}\\n    f = fs.open(fs.combine(path, \\\"ccdb.json\\\"), \\\"r\\\")\\n    db.settings = textutils.unserialiseJSON(f.readAll())\\n    db.path = path\\n    f.close()\\n    db.tables = db.settings.tables or {}\\n    function db.opentable(table_name)\\n        if not db.tables[table_name] then\\n            print(\\\"[ERROR]: Table \\\" .. table_name .. \\\" does not exist in database.\\\")\\n            return nil\\n        end\\n        f = fs.open(fs.combine(db.path, db.tables[table_name]), \\\"r\\\")\\n        local table = textutils.unserialiseJSON(f.readAll())\\n        f.close()\\n        return table\\n    end\\n\\n    function db.savetable(table_name, table)\\n        local waited = 0\\n        while fs.exists(fs.combine(db.path, db.tables[table_name]) .. \\\".lock\\\") == true and waited < 100 do\\n            sleep(0.1)\\n            waited = waited + 1\\n        end\\n\\n        if waited >= 100 then\\n            print(\\\"[ERROR]: Could not acquire lock for table \\\" .. table_name .. \\\".\\\")\\n            return nil\\n        end\\n\\n        f = fs.open(fs.combine(db.path, db.tables[table_name]) .. \\\".lock\\\", \\\"w\\\")\\n        f.write(\\\"lock\\\")\\n        f.close()\\n\\n        if not db.tables[table_name] then\\n            print(\\\"[ERROR]: Table \\\" .. table_name .. \\\" does not exist in database.\\\")\\n            return nil\\n        end\\n        f = fs.open(fs.combine(db.path, db.tables[table_name]), \\\"w\\\")\\n        f.write(textutils.serialiseJSON(table))\\n        f.close()\\n\\n        fs.delete(fs.combine(db.path, db.tables[table_name]) .. \\\".lock\\\")\\n        return true\\n    end\\n\\n    return db\\nend\\n\\nreturn dbmgr\\n\"}, {\"t\": 1, \"p\": \"src/main.lua\", \"c\": \"local runner = require(\\\"src.core.run\\\")\\nlocal dbmgr = require(\\\"src.fs.dbmgr\\\")\\n\\ndb = dbmgr.opendb(\\\"src/examples/db01\\\")\\n\\nstop = false\\n\\nwhile not stop do\\n    line = io.read(\\\"l\\\");\\n    if line == nil or line == \\\"exit\\\" then\\n        stop = true\\n    else\\n        result = runner.run(line, db)\\n\\n        print(textutils.serialize(result))\\n    end\\nend\\n\\n-- local ccdb_parse = require(\\\"src.parser.parser\\\")\\n-- local r = ccdb_parse.parse(\\n--     \\\"SELECT * FROM user WHERE name = 'Lyam Zambaz' OR city = 'Paris' AND age >= 18 ORDER BY age LIMIT 2;\\\")\\n-- print(textutils.serialize(r))\\n-- f = fs.open(\\\"debug_parse.txt\\\", \\\"w\\\")\\n-- f.write(textutils.serialize(r))\\n-- f.close()\\n\"}, {\"t\": 2, \"p\": \"src/parser\"}, {\"t\": 1, \"p\": \"src/parser/parser.lua\", \"c\": \"local parser = {}\\n\\nlocal strutils = require(\\\"src.utils.strutils\\\")\\nlocal parser_globals = require(\\\"src.parser.parse_globals\\\")\\n\\nfunction parser.analyze_value(value)\\n    for name, pattern in pairs(parser_globals.VALUE_TYPES) do\\n        _, _, captured = string.find(value, pattern)\\n        if captured then\\n            if name == \\\"STRING\\\" then\\n                return captured\\n            elseif name == \\\"FLOAT\\\" then\\n                return tonumber(captured)\\n            elseif name == \\\"INTEGER\\\" then\\n                return tonumber(captured)\\n            elseif name == \\\"BOOLEAN_TRUE\\\" then\\n                return true\\n            elseif name == \\\"BOOLEAN_FALSE\\\" then\\n                return false\\n            elseif name == \\\"NULL\\\" then\\n                return parser_globals.NULL\\n            end\\n        end\\n    end\\n    print(\\\"[ERROR]: Unable to analyze value: \\\" .. value)\\n    return nil\\nend\\n\\nfunction parser.where(query)\\n    local where_clause = string.match(strutils.str_trim(query), parser_globals.WHERE)\\n    if where_clause then\\n        local where_conditions = strutils.split_on_separators(where_clause, { \\\"AND\\\", \\\"OR\\\" }, true)\\n        local conditions = {}\\n        for k, where_condition in pairs(where_conditions) do\\n            local condition = strutils.str_trim(where_condition)\\n            local condition_type = nil\\n            if string.sub(condition, 1, 3) == \\\"AND\\\" then\\n                condition_type = \\\"AND\\\"\\n                condition = string.sub(condition, 4)\\n            elseif string.sub(condition, 1, 2) == \\\"OR\\\" then\\n                condition_type = \\\"OR\\\"\\n                condition = string.sub(condition, 3)\\n            end\\n            condition = strutils.str_trim(condition)\\n            _, _, col, operator, value = string.find(condition, parser_globals.WHERE_PATTERN)\\n            if col and operator and value then\\n                value = parser.analyze_value(strutils.str_trim(value))\\n                if not value then\\n                    print(\\\"[ERROR]: Unable to analyze value in WHERE condition: \\\" .. condition)\\n                    return nil\\n                end\\n                conditions[k] = {\\n                    type = condition_type,\\n                    column = col,\\n                    operator = operator,\\n                    value = value\\n                }\\n            else\\n                print(\\\"[ERROR]: Invalid WHERE condition: \\\" .. condition)\\n                return nil\\n            end\\n        end\\n        return conditions\\n    end\\n    return {}\\nend\\n\\nfunction parser.end_section(query_end)\\n    local limit_number = nil\\n    local collumns = {}\\n    local trimmed_end = strutils.str_trim(query_end)\\n    if trimmed_end == \\\"\\\" then\\n        return {\\n            order_by = collumns,\\n            limit = limit_number\\n        }\\n    end\\n    trimmed_end = strutils.strsplit(trimmed_end, \\\"LIMIT\\\")[1] -- Remove LIMIT part if present\\n    local _, _, orders = string.find(trimmed_end, parser_globals.SELECT_ORDER_BY)\\n    if orders then\\n        local order_columns = strutils.strsplit(strutils.str_trim(orders), \\\",\\\")\\n        for k, col in pairs(order_columns) do\\n            local column = strutils.str_trim(col)\\n            local _, _, col_name, order = string.find(column, parser_globals.SELECT_ORDER_BY_SINGLE)\\n            if col_name and order then\\n                if order == \\\"\\\" then\\n                    order = \\\"ASC\\\"\\n                else\\n                    if order ~= \\\"ASC\\\" and order ~= \\\"DESC\\\" and order ~= \\\"\\\" then\\n                        print(\\\"[ERROR]: Invalid ORDER BY order: \\\" .. order)\\n                        return nil\\n                    end\\n                    if order == \\\"\\\" then\\n                        order = \\\"ASC\\\"\\n                    end\\n                end\\n\\n                collumns[k] = {\\n                    column = col_name,\\n                    order = order\\n                }\\n            else\\n                print(\\\"[ERROR]: Invalid ORDER BY part: \\\" .. column)\\n            end\\n        end\\n    end\\n    local _, _, limit = string.find(strutils.str_trim(query_end), parser_globals.SELECT_LIMIT)\\n    if limit then\\n        limit_number = tonumber(strutils.str_trim(limit))\\n        if not limit_number then\\n            print(\\\"[ERROR]: Invalid LIMIT number: \\\" .. limit)\\n            return nil\\n        end\\n    end\\n    return {\\n        order_by = collumns,\\n        limit = limit_number\\n    }\\nend\\n\\nfunction parser.parse_select(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*$\\\", \\\"\\\")\\n    _, _, indexes, sqltable = string.find(query_filtred, parser_globals.SELECT_FROM)\\n    if indexes and sqltable then\\n        indexes_clean = indexes:gsub(\\\"%s+\\\", \\\"\\\")\\n        returned = {\\n            type = \\\"select\\\",\\n            data = {},\\n            from = sqltable\\n        }\\n        if indexes_clean == \\\"*\\\" then\\n            indexes_clean = \\\"\\\"\\n            returned[\\\"data\\\"][\\\"return_cols_all\\\"] = true\\n        else\\n            local indexes = strutils.strsplit(indexes_clean, \\\",\\\")\\n            returned[\\\"data\\\"][\\\"return_cols\\\"] = indexes\\n        end\\n    else\\n        print(\\\"[ERROR]: Unable to parse SELECT indexes and FROM table.\\\")\\n        return nil\\n    end\\n    local query_cleaned = query_filtred:gsub(parser_globals.SELECT_FROM_ONLY, \\\"\\\"):gsub(\\\";$\\\", \\\"\\\"); -- Remove processed parts and semicolon\\n    if query_cleaned == \\\"\\\" then\\n        returned[\\\"data\\\"][\\\"where\\\"] = {}\\n        returned[\\\"data\\\"][\\\"limit\\\"] = nil\\n        return returned\\n    end\\n    local where_clause = strutils.split_on_separators(query_cleaned, { \\\"ORDER\\\", \\\"LIMIT\\\" }, false)[1]; -- Remove end section if present\\n    if string.find(where_clause, parser_globals.WHERE) ~= nil then\\n        local where_parsed = parser.where(where_clause)\\n        if not where_parsed then\\n            print(\\\"[ERROR]: Unable to parse WHERE clause.\\\")\\n            return nil\\n        end\\n        returned[\\\"data\\\"][\\\"where\\\"] = where_parsed\\n    else\\n        returned[\\\"data\\\"][\\\"where\\\"] = {}\\n    end\\n    query_cleaned = strutils.safe_replace(query_cleaned, where_clause, \\\"\\\"):gsub(\\\";$\\\", \\\"\\\"); -- Remove processed WHERE part and semicolon\\n    query_cleaned = strutils.str_trim(query_cleaned)\\n    local ending_parsed = parser.end_section(query_cleaned)\\n    if not ending_parsed then\\n        print(\\\"[ERROR]: Unable to parse END section.\\\")\\n        return nil\\n    end\\n    returned[\\\"data\\\"][\\\"limit\\\"] = ending_parsed[\\\"limit\\\"]\\n    returned[\\\"data\\\"][\\\"order_by\\\"] = ending_parsed[\\\"order_by\\\"]\\n    return returned\\nend\\n\\nfunction parser.parse_insert(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*;$\\\", \\\"\\\")\\n    _, _, sqltable, columns, values = string.find(query_filtred, parser_globals.INSERT_INTO)\\n    if sqltable and columns and values then\\n        local columns_list_raw = strutils.strsplit(strutils.str_trim(columns), \\\",\\\")\\n        local values_lists_raw = strutils.split_on_single_char(values, \\\")\\\")\\n        local values_lists = {}\\n        for k, value in pairs(values_lists_raw) do\\n            local _, _, cleaned_value = string.find(value, parser_globals.INSERT_CLEANUP)\\n            if cleaned_value then\\n                local value_items_raw = strutils.split_on_single_char(strutils.str_trim(cleaned_value), \\\",\\\")\\n                local value_items = {}\\n                for _, item in pairs(value_items_raw) do\\n                    local analyzed_value = parser.analyze_value(strutils.str_trim(item))\\n                    if analyzed_value == nil then\\n                        print(\\\"[ERROR]: Unable to analyze value in INSERT: \\\" .. item)\\n                        return nil\\n                    end\\n                    table.insert(value_items, analyzed_value)\\n                end\\n                table.insert(values_lists, value_items)\\n            end\\n        end\\n        for k, col in pairs(columns_list_raw) do\\n            columns_list_raw[k] = strutils.str_trim(col:gsub(\\\"%(*\\\", \\\"\\\"):gsub(\\\"%)*\\\", \\\"\\\"))\\n        end\\n        returned = {\\n            type = \\\"insert\\\",\\n            data = {\\n                columns = columns_list_raw,\\n                values = values_lists\\n            },\\n            from = sqltable\\n        }\\n    end\\n    return returned\\nend\\n\\nfunction parser.parse_update(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*;$\\\", \\\"\\\")\\n    _, _, sqltable, other_parts = string.find(query_filtred, parser_globals.UPDATE)\\n    if sqltable and other_parts then\\n        local query_cleaned = query_filtred:gsub(parser_globals.UPDATE_ONLY, \\\"\\\"):gsub(\\\";$\\\", \\\"\\\")\\n        local parts = strutils.split_on_separators(query_cleaned, { \\\"WHERE\\\" }, false); -- Remove WHERE if present\\n        local set_clause = parts[1]\\n        local set_parts_raw = strutils.split_on_single_char(set_clause, \\\",\\\")\\n        local set_parts = {}\\n        for k, part in pairs(set_parts_raw) do\\n            local _, _, col, value = string.find(strutils.str_trim(part), parser_globals.UPDATE_PART)\\n            if col and value then\\n                local analyzed_value = parser.analyze_value(strutils.str_trim(value))\\n                if analyzed_value == nil then\\n                    print(\\\"[ERROR]: Unable to analyze value in UPDATE SET: \\\" .. value)\\n                    return nil\\n                end\\n                set_parts[k] = {\\n                    column = col,\\n                    value = analyzed_value\\n                }\\n            else\\n                print(\\\"[ERROR]: Invalid UPDATE SET part: \\\" .. part)\\n                return nil\\n            end\\n        end\\n        if #parts < 2 then\\n            parts[2] = \\\"\\\"\\n        end\\n        local where_clause = parts[2]:gsub(\\\";$\\\", \\\"\\\"); -- Remove semicolon if present\\n        local where_parsed = nil\\n        if where_clause then\\n            where_parsed = parser.where(\\\"WHERE \\\" .. where_clause)\\n            if not where_parsed then\\n                print(\\\"[ERROR]: Unable to parse WHERE clause in UPDATE.\\\")\\n                return nil\\n            end\\n        end\\n        returned = {\\n            type = \\\"update\\\",\\n            data = {\\n                set = set_parts,\\n                where = where_parsed\\n            },\\n            from = sqltable\\n        }\\n    end\\n    return returned\\nend\\n\\nfunction parser.parse_delete(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*;$\\\", \\\"\\\")\\n    _, _, sqltable, where = string.find(query_filtred, parser_globals.DELETE)\\n    if sqltable and where then\\n        local where_parsed = parser.where(where)\\n        if not where_parsed then\\n            print(\\\"[ERROR]: Unable to parse WHERE clause in DELETE.\\\")\\n            return nil\\n        end\\n        returned = {\\n            type = \\\"delete\\\",\\n            data = {\\n                where = where_parsed\\n            },\\n            from = sqltable\\n        }\\n    end\\n    return returned\\nend\\n\\nfunction parser.parse(query)\\n    local query_type = string.match(strutils.str_trim(query), parser_globals.QUERY_TYPE)\\n    if query_type == \\\"SELECT\\\" then\\n        return parser.parse_select(query)\\n    elseif query_type == \\\"INSERT\\\" then\\n        return parser.parse_insert(query)\\n    elseif query_type == \\\"UPDATE\\\" then\\n        return parser.parse_update(query)\\n    elseif query_type == \\\"DELETE\\\" then\\n        return parser.parse_delete(query)\\n    else\\n        print(\\\"[ERROR]: Unknown query type.\\\")\\n        return nil\\n    end\\nend\\n\\nreturn parser\\n\"}, {\"t\": 1, \"p\": \"src/parser/parse_globals.lua\", \"c\": \"-- Patterns\\n\\nlocal parse_globals = {}\\nparse_globals.SELECT_FROM = \\\"^SELECT ([%a_,*%s*%*]+) FROM ([%a_]+)%s*.*;$\\\"\\nparse_globals.SELECT_FROM_ONLY = \\\"^SELECT ([%a_,*%s*]+) FROM ([%a_]+)%s*\\\"\\nparse_globals.WHERE = \\\"WHERE%s+(.*)%s*\\\"\\nparse_globals.WHERE_PATTERN = \\\"^([%a_]+)%s*([<>!=%%]+)%s*(.*)$\\\"\\nparse_globals.SELECT_ORDER_BY = \\\"ORDER%s+BY%s+([%a_,%s]+)\\\"\\nparse_globals.SELECT_ORDER_BY_SINGLE = \\\"([%a_]+)%s*([%a]*)\\\"; -- check of ASC/DESC will be done in parser\\nparse_globals.SELECT_LIMIT = \\\"LIMIT%s+(%d+)$\\\"\\nparse_globals.INSERT_INTO = \\\"^INSERT%s+INTO%s+([%a_]+)%s*(%([%s%a_,]+%))%s*VALUES%s+(.*);$\\\"\\nparse_globals.INSERT_CLEANUP = \\\"^,?%s*%((.*)$\\\"\\nparse_globals.UPDATE = \\\"^UPDATE%s+([%a_]+)%s+SET%s+(.*);$\\\"\\nparse_globals.UPDATE_ONLY = \\\"^UPDATE%s+([%a_]+)%s+SET%s+\\\"\\nparse_globals.UPDATE_PART = \\\"^([%a_]+)%s*=%s*(.*)\\\"\\nparse_globals.DELETE = \\\"^DELETE%s+FROM%s+([%a_]+)%s*(.*);$\\\"\\nparse_globals.QUERY_TYPE = \\\"^([%a]+)%s\\\"\\nparse_globals.VALUE_TYPES = {\\n    STRING = \\\"^'(.*)'$\\\",\\n    FLOAT = \\\"^(%-?%d+%.?%d*)$\\\",\\n    INTEGER = \\\"^(%-?%d+)$\\\",\\n    BOOLEAN_TRUE = \\\"^(TRUE)$\\\",\\n    BOOLEAN_FALSE = \\\"^(FALSE)$\\\",\\n    NULL = \\\"^(NULL)$\\\"\\n}\\n\\nparse_globals.NULL = {\\n    type = \\\"null\\\",\\n    value = nil\\n}; -- Used so we can differentiate between a NULL value and a missing value\\n\\nreturn parse_globals\\n\"}, {\"t\": 2, \"p\": \"src/utils\"}, {\"t\": 1, \"p\": \"src/utils/rednet.lua\", \"c\": \"local rednet_mod\\nrednet_cfg_module = nil\\nfunction rednet_mod.rednet_setup(module_loc)\\n    rednet_cfg_module = module_loc\\n    rednet.open(module_loc)\\nend\\n\\nfunction rednet_mod.server(callback, api)\\n    if not rednet_cfg_module then\\n        print(\\\"Tried to run a server without rednet_setup() called first\\\")\\n        return\\n    end\\n    stop = false\\n    while not stop do\\n        res = rednet.receive()\\n        stop = not callback(res)\\n    end\\nend\\n\\nreturn rednet_mod\\n\"}, {\"t\": 1, \"p\": \"src/utils/strutils.lua\", \"c\": \"-- http://lua-users.org/wiki/StringTrim\\n\\nlocal strutils = {}\\n\\nfunction strutils.str_trim(stri)\\n    return stri:match(\\\"^%s*(.-)%s*$\\\")\\nend\\n\\n-- Source - https://stackoverflow.com/a\\n-- Posted by user973713, modified by community. See post 'Timeline' for change history\\n-- Retrieved 2025-12-12, License - CC BY-SA 4.0\\n\\nfunction strutils.strsplit(inputstr, sep)\\n    if sep == nil then\\n        sep = \\\"%s\\\"\\n    end\\n    local t = {}\\n    for str in string.gmatch(inputstr, \\\"([^\\\" .. sep .. \\\"]+)\\\") do\\n        table.insert(t, str)\\n    end\\n    return t\\nend\\n\\n-- From me\\n-- Safely replaces a pattern in a string by escaping all non-word characters in the pattern\\nfunction strutils.safe_replace(str, pattern, replacement)\\n    local escaped_pattern = pattern:gsub(\\\"(%W)\\\", \\\"%%%1\\\")\\n    return str:gsub(escaped_pattern, replacement)\\nend\\n\\n-- Ik, it's not the best way to do it, but whatever.\\n-- This is not by me. I don't remember where I found it.\\n-- It basically splits a string on multiple separators, ignoring those inside quotes.\\nfunction strutils.split_on_separators(str, seps, keep_seps)\\n    local sep_lookup = {}\\n    for _, s in ipairs(seps) do\\n        sep_lookup[s] = true\\n    end\\n\\n    local result = {}\\n    local current = {}\\n\\n    local in_single = false\\n    local in_double = false\\n\\n    for token in str:gmatch(\\\"%S+\\\") do\\n        for i = 1, #token do\\n            local char = token:sub(i, i)\\n            if char == \\\"'\\\" then in_single = not in_single end\\n            if char == '\\\"' then in_double = not in_double end\\n        end\\n\\n        local inside_quotes = in_single or in_double\\n        if not inside_quotes and sep_lookup[token] then\\n            if keep_seps then\\n                table.insert(result, table.concat(current, \\\" \\\"))\\n                current = {}\\n                table.insert(current, token .. \\\" \\\")\\n            else\\n                table.insert(result, table.concat(current, \\\" \\\"))\\n                current = {}\\n            end\\n        else\\n            table.insert(current, token)\\n        end\\n    end\\n\\n    if #current > 0 then\\n        table.insert(result, table.concat(current, \\\" \\\"))\\n    end\\n\\n    return result\\nend\\n\\nfunction strutils.split_on_single_char(str, char)\\n    local result = {}\\n    local current = {}\\n\\n    local in_single = false\\n    local in_double = false\\n\\n    for k, token in pairs(strutils.totable(str)) do\\n        if token:sub(1, 1) == \\\"'\\\" then in_single = not in_single end\\n        if token:sub(1, 1) == '\\\"' then in_double = not in_double end\\n        if token:sub(-1) == \\\"'\\\" then in_single = not in_single end\\n        if token:sub(-1) == '\\\"' then in_double = not in_double end\\n\\n        local inside_quotes = in_single or in_double\\n\\n        if not inside_quotes and token == char then\\n            table.insert(result, table.concat(current))\\n            current = {}\\n        else\\n            table.insert(current, token)\\n        end\\n    end\\n\\n    if #current > 0 then\\n        table.insert(result, table.concat(current))\\n    end\\n\\n    return result\\nend\\n\\nfunction strutils.totable(str)\\n    local t = {}\\n    str:gsub(\\\".\\\", function(c) table.insert(t, c) end)\\n    return t\\nend\\n\\nreturn strutils\\n\"}, {\"t\": 1, \"p\": \"src/utils/tableutils.lua\", \"c\": \"-- Table utils\\n\\nlocal tableutils = {}\\n\\nfunction tableutils.extend(list, otherlist)\\n    for _, v in ipairs(otherlist) do\\n        table.insert(list, v)\\n    end\\n    return list\\nend\\n\\n-- Source - https://stackoverflow.com/a\\n-- Posted by Chris\\n-- Retrieved 2025-12-12, License - CC BY-SA 3.0\\n\\nfunction tableutils.compare(one, two)\\n    if type(one) == type(two) then\\n        if type(one) == \\\"table\\\" then\\n            if #one == #two then\\n                -- If both types are the same, both are tables and\\n                -- the tables are the same size, recurse through each\\n                -- table entry.\\n                for loop = 1, #one do\\n                    if tableutils.compare(one[loop], two[loop]) == false then\\n                        return false\\n                    end\\n                end\\n\\n                -- All table contents match\\n                return true\\n            end\\n        else\\n            -- Values are not tables but matching types. Compare\\n            -- them and return if they match\\n            return one == two\\n        end\\n    end\\n    return false\\nend\\n\\nreturn tableutils\\n\"}]"
files = textutils.unserialiseJSON(JSON)

for key, val in pairs(files) do
    if val["t"] == 2 then
        fs.makeDir(fs.combine(root, val["p"]))
    end
    if val["t"] == 1 then
        local file = fs.open(fs.combine(root, val["p"]), "w")
        print("[SETUP]: Writing to " .. val["p"])
        file.write(val["c"])
        file.close()
    end
end


require(root_runtime .. "." .. "main")
