
local is_setup = arg[1] == "setup"

local root = "/"
local root_runtime = "src"
local JSON = "[{\"t\": 1, \"p\": \"src/.buildnumber\", \"c\": \"1765647422\"}, {\"t\": 2, \"p\": \"src/core\"}, {\"t\": 1, \"p\": \"src/core/delete.lua\", \"c\": \"local wherecore = require(\\\"src.core.where\\\")\\nlocal tablecheck = require(\\\"src.core.tablecheck\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal deletecore = {}\\n\\nfunction deletecore.delete(query_serialized, db)\\n    current_table = db.opentable(query_serialized.from)\\n    if current_table == nil then\\n        errmgr.error(\\\"Table '\\\" .. query_serialized.from .. \\\"' does not exist.\\\")\\n        return false\\n    end\\n\\n    if query_serialized.data.where and next(query_serialized.data.where) then\\n        local where_filtered = wherecore.appy_where(query_serialized.data.where, current_table.data)\\n        results = where_filtered\\n    else\\n        results = current_table.data\\n    end\\n\\n    -- Because the results is linked to current_table.data, at the end of the function we will have 0 rows in results\\n    local nbr_deleted = #results\\n\\n    local indices_to_delete = {}\\n    for _, row in ipairs(results) do\\n        for i = 1, #current_table.data do\\n            local data = current_table.data[i]\\n            if data[\\\"?sysid?\\\"] == row[\\\"?sysid?\\\"] then\\n                table.insert(indices_to_delete, i)\\n                break\\n            end\\n        end\\n    end\\n\\n    for i = #indices_to_delete, 1, -1 do\\n        table.remove(current_table.data, indices_to_delete[i])\\n    end\\n\\n    if not tablecheck.check_table(current_table) then\\n        errmgr.error(\\\"Delete operation aborted due to table constraint violations (type, not null, etc.).\\\")\\n        return false\\n    end\\n\\n    db.savetable(query_serialized.from, current_table)\\n    return {\\n        success = true,\\n        affected_rows = nbr_deleted\\n    }\\nend\\n\\nreturn deletecore\\n\"}, {\"t\": 1, \"p\": \"src/core/errmgr.lua\", \"c\": \"local globals = require(\\\"src.globals\\\")\\n\\nlocal err = {}\\nlocal cfg = {} -- {dbg = true/false, log = true/false, log_path = \\\"path/to/logfile\\\"}\\n\\nlocal errmgr = {}\\n\\nif fs.exists(\\\"config/log.json\\\") then\\n    local file = fs.open(\\\"config/log.json\\\", \\\"r\\\")\\n    local content = file.readAll()\\n    file.close()\\n    cfg = textutils.unserializeJSON(content)\\nelse\\n    cfg = { dbg = false, log = true, log_path = \\\"logs/error.log\\\" }\\n    local file = fs.open(\\\"config/log.json\\\", \\\"w\\\")\\n    file.write(textutils.serializeJSON(cfg))\\n    file.close()\\nend\\n\\nfunction errmgr.error(message)\\n    local full_msg = message\\n    if cfg.dbg then\\n        full_msg = debug.traceback(message, 2)\\n    end\\n    if cfg.dbg then\\n        print(\\\"[ERROR]: \\\" .. full_msg)\\n    end\\n    if cfg.log then\\n        local log_message = \\\"[\\\" .. os.date(\\\"%Y-%m-%d %H:%M:%S\\\") .. \\\"] \\\" .. full_msg .. \\\"\\\\n\\\"\\n        local file = fs.open(cfg.log_path, \\\"a\\\")\\n        file.write(log_message)\\n        file.close()\\n    end\\n    table.insert(err, #err + 1, full_msg)\\n    error(\\n        \\\"An error occurred during execution. Check logs for details. (A report should be generated and sent)\\\",\\n        0)\\nend\\n\\nfunction errmgr.generate_report(error)\\n    local report = \\\"-------- ERROR REPORT --------\\\\nThe following errors were recorded during execution:\\\\n\\\"\\n    for i, message in ipairs(err) do\\n        report = report .. \\\"[\\\" .. i .. \\\"] \\\" .. message .. \\\"\\\\n\\\"\\n    end\\n    report = report .. \\\"[\\\" .. (#err + 1) .. \\\"] \\\" .. tostring(error) .. \\\"\\\\n\\\"\\n    report = report .. \\\"Environment Info:\\\\n\\\"\\n    report = report .. \\\"CCDB Version: \\\" .. globals.VERSION .. \\\"\\\\n\\\"\\n    report = report .. \\\"CCDB Server Build: \\\" .. globals.BUILD .. \\\"\\\\n\\\"\\n    return report\\nend\\n\\nreturn errmgr\\n\"}, {\"t\": 1, \"p\": \"src/core/insert.lua\", \"c\": \"local tablecheck = require(\\\"src.core.tablecheck\\\")\\nlocal parseglobals = require(\\\"src.parser.parse_globals\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal insertcore = {}\\n\\nfunction insertcore.insert(serialized_query, db)\\n    local table_name = serialized_query.from\\n    local current_table = db.opentable(serialized_query.from)\\n    if not current_table then\\n        errmgr.error(\\\"Table '\\\" .. table_name .. \\\"' does not exist.\\\")\\n        return nil\\n    end\\n\\n    local columns = serialized_query.data.columns\\n    local values = serialized_query.data.values\\n    for _, value_set in ipairs(values) do\\n        local new_row = {}\\n        for i, column in pairs(current_table.schema.fields) do\\n            local col_name = i\\n            local col_index = nil\\n            for j, col in ipairs(columns) do\\n                if col == col_name then\\n                    col_index = j\\n                    break\\n                end\\n            end\\n            if col_index then\\n                if value_set[col_index] == parseglobals.NULL then\\n                    new_row[col_name] = nil\\n                else\\n                    new_row[col_name] = value_set[col_index]\\n                end\\n            else\\n                if column.default ~= nil and column.default ~= nil then\\n                    new_row[col_name] = column.default\\n                else\\n                    local stop = false\\n                    local index = 1\\n                    while not stop and index <= #current_table.schema.indexes do\\n                        local idx = current_table.schema.indexes[index]\\n                        if idx.field == col_name and idx.type == \\\"ai\\\" then\\n                            new_row[col_name] = idx.current\\n                            idx.current = idx.current + 1\\n                            stop = true\\n                        end\\n                        index = index + 1\\n                    end\\n                end\\n            end\\n        end\\n        new_row[\\\"?sysid?\\\"] = current_table.schema.current_sysid\\n        current_table.schema.current_sysid = current_table.schema.current_sysid + 1\\n        table.insert(current_table.data, new_row)\\n    end\\n\\n    if not tablecheck.check_table(current_table) then\\n        errmgr.error(\\\"Table '\\\" ..\\n            table_name .. \\\"' integrity check failed after INSERT operation. (Rolling back changes.)\\\")\\n        return nil\\n    end\\n    db.savetable(table_name, current_table)\\n    return {\\n        success = true,\\n        affected_rows = #values\\n    }\\nend\\n\\nreturn insertcore\\n\"}, {\"t\": 1, \"p\": \"src/core/run.lua\", \"c\": \"local ccdb_parse = require(\\\"src.parser.parser\\\")\\nlocal selectcore = require(\\\"src.core.select\\\")\\nlocal insertcore = require(\\\"src.core.insert\\\")\\nlocal updatecore = require(\\\"src.core.update\\\")\\nlocal deletecore = require(\\\"src.core.delete\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\nlocal runner = {}\\n\\nrunner.time_start = 0\\n\\nfunction runner.run(query, db)\\n    runner.time_start = os.clock()\\n    serialized_query = ccdb_parse.parse(query)\\n    if not serialized_query then\\n        errmgr.error(\\\"Unable to parse query.\\\")\\n        return nil; -- I will add error processing later\\n    end\\n    if serialized_query.type == \\\"select\\\" then\\n        return selectcore.select(serialized_query, db)\\n    elseif serialized_query.type == \\\"insert\\\" then\\n        return insertcore.insert(serialized_query, db)\\n    elseif serialized_query.type == \\\"update\\\" then\\n        return updatecore.update(serialized_query, db)\\n    elseif serialized_query.type == \\\"delete\\\" then\\n        return deletecore.delete(serialized_query, db)\\n    else\\n        errmgr.error(\\\"Query type '\\\" .. serialized_query.type .. \\\"' not supported yet.\\\")\\n        return nil; -- I will add error processing later\\n    end\\nend\\n\\nreturn runner\\n\"}, {\"t\": 1, \"p\": \"src/core/select.lua\", \"c\": \"local wherecore = require(\\\"src.core.where\\\")\\nlocal safecalc = require(\\\"src.utils.safecalc\\\")\\n\\nlocal selectcore = {}\\n\\nfunction selectcore.select(query_serialized, db)\\n    current_table = db.opentable(query_serialized.from)\\n    local results = {}\\n    if query_serialized.data.where and next(query_serialized.data.where) then\\n        local where_filtered = wherecore.appy_where(query_serialized.data.where, current_table.data)\\n        results = where_filtered\\n    else\\n        results = current_table.data\\n    end\\n\\n    table.sort(results, function(a, b)\\n        for _, order_rule in ipairs(query_serialized.data.order_by or {}) do\\n            local col = order_rule.column\\n            local order = order_rule.order\\n            if a[col] ~= b[col] then\\n                if order == \\\"ASC\\\" then\\n                    return a[col] < b[col]\\n                else\\n                    return a[col] > b[col]\\n                end\\n            end\\n        end\\n        return false\\n    end)\\n\\n    if query_serialized.data.limit then\\n        local limited_results = {}\\n        for i = 1, math.min(query_serialized.data.limit, #results) do\\n            table.insert(limited_results, results[i])\\n        end\\n        results = limited_results\\n    end\\n    for i, row in ipairs(results) do\\n        local filtered_row = {}\\n        for col, value in pairs(row) do\\n            if col ~= \\\"?sysid?\\\" then\\n                if not query_serialized.data.return_cols_all then\\n                    for _, select_col in ipairs(query_serialized.data.return_cols) do\\n                        if col == select_col.value then\\n                            filtered_row[col] = value\\n                        end\\n                    end\\n                else\\n                    filtered_row[col] = value\\n                end\\n            end\\n        end\\n        for _, select_col in ipairs(query_serialized.data.return_cols or {}) do\\n            if type(select_col) ~= \\\"table\\\" or select_col.type ~= \\\"column\\\" then\\n                value = select_col\\n                if type(value) == \\\"table\\\" and value.type == \\\"calculation\\\" then\\n                    value = safecalc.safe_calc(value.value, row)\\n                end\\n                filtered_row[\\\"col_\\\" .. tostring(#filtered_row + 1)] = value -- AS not supported yet\\n            end\\n        end\\n        results[i] = filtered_row\\n    end\\n    return results\\nend\\n\\nreturn selectcore\\n\"}, {\"t\": 1, \"p\": \"src/core/tablecheck.lua\", \"c\": \"local errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal tablecheckcore = {}\\n\\nfunction tablecheckcore.check_table(table)\\n    -- First: check for NOT NULL constraints\\n    for _, row in ipairs(table.data) do\\n        for col_name, col_schema in pairs(table.schema.fields) do\\n            if col_schema.nullable == false and (row[col_name] == nil) then\\n                errmgr.error(\\\"NOT NULL constraint violated for column '\\\" .. col_name .. \\\"'.\\\")\\n                return false\\n            end\\n        end\\n    end\\n    -- Second: check for TYPES\\n    for _, row in ipairs(table.data) do\\n        for col_name, col_schema in pairs(table.schema.fields) do\\n            local value = row[col_name]\\n            if value ~= nil then\\n                local value_type = col_schema.type[1]\\n\\n                if value == nil then\\n                    value_type = \\\"null\\\" -- Handle NULL case\\n                end\\n\\n                if value_type == \\\"varchar\\\" then\\n                    local max_length = col_schema.type[2]\\n                    if type(value) ~= \\\"string\\\" then\\n                        errmgr.error(\\\"Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected VARCHAR.\\\")\\n                        return false\\n                    end\\n                    if #value > max_length then\\n                        errmgr.error(\\\"Length constraint violated for column '\\\" ..\\n                            col_name .. \\\"'. Maximum length is \\\" .. max_length .. \\\".\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"int\\\" then\\n                    if type(value) ~= \\\"number\\\" or value % 1 ~= 0 then\\n                        errmgr.error(\\\"Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected INT.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"float\\\" then\\n                    if type(value) ~= \\\"number\\\" then\\n                        errmgr.error(\\\"Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected FLOAT.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"boolean\\\" then\\n                    if type(value) ~= \\\"boolean\\\" then\\n                        errmgr.error(\\\"Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected BOOLEAN.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"null\\\" then\\n                    if value ~= nil then\\n                        errmgr.error(\\\"Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected NULL.\\\")\\n                        return false\\n                    end\\n                elseif value_type == \\\"text\\\" then\\n                    if type(value) ~= \\\"string\\\" then\\n                        errmgr.error(\\\"Type constraint violated for column '\\\" .. col_name .. \\\"'. Expected TEXT.\\\")\\n                        return false\\n                    end\\n                end\\n            end\\n        end\\n    end\\n\\n    -- Check for UNIQUE constraints (and PRIMARY KEY, which is a special case of UNIQUE)\\n\\n    for i, index_data in ipairs(table.schema.indexes) do\\n        if index_data.type == \\\"unique\\\" or index_data.type == \\\"pk\\\" then\\n            local seen_values = {}\\n            for _, row in ipairs(table.data) do\\n                local value = row[index_data.field]\\n                if value ~= nil then\\n                    if seen_values[value] then\\n                        errmgr.error(\\\"UNIQUE constraint violated for column '\\\" .. index_data.field .. \\\"'.\\\")\\n                        return false\\n                    else\\n                        seen_values[value] = true\\n                    end\\n                end\\n            end\\n        end\\n    end\\n    return true\\nend\\n\\nreturn tablecheckcore\\n\"}, {\"t\": 1, \"p\": \"src/core/update.lua\", \"c\": \"local wherecore = require(\\\"src.core.where\\\")\\nlocal tablecheck = require(\\\"src.core.tablecheck\\\")\\nlocal parseglobals = require(\\\"src.parser.parse_globals\\\")\\nlocal safecalc = require(\\\"src.utils.safecalc\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal updatecore = {}\\n\\nfunction updatecore.update(query_serialized, db)\\n    current_table = db.opentable(query_serialized.from)\\n    if current_table == nil then\\n        errmgr.error(\\\"Table '\\\" .. query_serialized.from .. \\\"' does not exist.\\\")\\n        return false\\n    end\\n\\n    if query_serialized.data.where and next(query_serialized.data.where) then\\n        local where_filtered = wherecore.appy_where(query_serialized.data.where, current_table.data)\\n        results = where_filtered\\n    else\\n        results = current_table.data\\n    end\\n\\n    for _, row in ipairs(results) do\\n        for i, data in ipairs(current_table.data) do\\n            if data[\\\"?sysid?\\\"] == row[\\\"?sysid?\\\"] then\\n                for _, set_clause in ipairs(query_serialized.data.set) do\\n                    local col_name = set_clause.column\\n                    local new_value = set_clause.value\\n                    if type(new_value) == \\\"table\\\" and new_value.type == \\\"calculation\\\" then\\n                        new_value = safecalc.safe_calc(new_value.value, row)\\n                    end\\n                    for _, index in ipairs(current_table.schema.indexes) do\\n                        if index.field == col_name and index.type == \\\"pk\\\" then\\n                            errmgr.error(\\\"Cannot update PRIMARY KEY column '\\\" .. col_name .. \\\"'.\\\")\\n                            return false\\n                        end\\n                    end\\n                    if new_value == parseglobals.NULL then\\n                        new_value = nil\\n                    end\\n                    current_table.data[i][col_name] = new_value\\n                end\\n            end\\n        end\\n    end\\n\\n    if not tablecheck.check_table(current_table) then\\n        errmgr.error(\\\"Update operation aborted due to table constraint violations (type, not null, etc.).\\\")\\n        return false\\n    end\\n\\n    db.savetable(query_serialized.from, current_table)\\n    return {\\n        success = true,\\n        affected_rows = #results\\n    }\\nend\\n\\nreturn updatecore\\n\\n-- {\\n--     data = {\\n--         set = {\\n--             {\\n--                 value = \\\"none@none.none\\\",\\n--                 column = \\\"email\\\"\\n--             }\\n--         },\\n--         where = {\\n--             {\\n--                 column = \\\"id\\\",\\n--                 operator = \\\"=\\\",\\n--                 value = 1\\n--             }\\n--         }\\n--     },\\n--     from = \\\"users\\\",\\n--     type = \\\"update\\\"\\n-- }\\n\"}, {\"t\": 1, \"p\": \"src/core/where.lua\", \"c\": \"local parse_globals = require(\\\"src.parser.parse_globals\\\")\\nlocal safecalc = require(\\\"src.utils.safecalc\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal wherecore = {}\\n\\nfunction wherecore.appy_where(conditions, current_table)\\n    local results = {}\\n\\n    for _, row in ipairs(current_table) do\\n        local conditions_met = {}\\n\\n        -- First evaluate all conditions, no matter the type\\n        for _, condition in ipairs(conditions) do\\n            local column_value = row[condition.column]\\n            local condition_value = condition.value\\n            if type(condition_value) == \\\"table\\\" and condition_value.type == \\\"calculation\\\" then\\n                condition_value = safecalc.safe_calc(condition_value.value, row)\\n            end\\n            local operator = condition.operator\\n            local condition_met = false\\n\\n            if condition_value == parse_globals.NULL then\\n                condition_value = nil\\n            end\\n\\n            if operator == \\\"=\\\" then\\n                condition_met = (column_value == condition_value)\\n            elseif operator == \\\"!=\\\" then\\n                condition_met = (column_value ~= condition_value)\\n            elseif operator == \\\">\\\" then\\n                condition_met = (column_value > condition_value)\\n            elseif operator == \\\"<\\\" then\\n                condition_met = (column_value < condition_value)\\n            elseif operator == \\\">=\\\" then\\n                condition_met = (column_value >= condition_value)\\n            elseif operator == \\\"<=\\\" then\\n                condition_met = (column_value <= condition_value)\\n            elseif operator == \\\"%\\\" then\\n                ---@diagnostic disable-next-line: need-check-nil\\n                local pattern = condition_value:gsub(\\\"%%\\\", \\\".*\\\"):gsub(\\\"_\\\", \\\".\\\")\\n                condition_met = string.match(tostring(column_value), \\\"^\\\" .. pattern .. \\\"$\\\") ~= nil\\n            else\\n                errmgr.error(\\\"Unknown operator '\\\" .. operator .. \\\"' in WHERE clause.\\\")\\n            end\\n            table.insert(conditions_met, {\\n                met = condition_met,\\n                type = condition.type\\n            })\\n        end\\n\\n        local groups = {}\\n        local current_and = true\\n        local first = true\\n\\n        for i, cond in ipairs(conditions_met) do\\n            if first then\\n                current_and = cond.met\\n                first = false\\n            else\\n                if cond.type == \\\"AND\\\" then\\n                    current_and = current_and and cond.met\\n                elseif cond.type == \\\"OR\\\" then\\n                    table.insert(groups, current_and)\\n                    current_and = cond.met\\n                end\\n            end\\n        end\\n\\n        -- push last AND group\\n        table.insert(groups, current_and)\\n\\n        -- OR all groups\\n        local stop = false\\n        local i = 1\\n        while not stop and i <= #groups do\\n            if groups[i] then\\n                table.insert(results, row)\\n                stop = true\\n            end\\n            i = i + 1\\n        end\\n    end\\n    return results\\nend\\n\\nreturn wherecore\\n\"}, {\"t\": 2, \"p\": \"src/examples\"}, {\"t\": 2, \"p\": \"src/examples/dbtest\"}, {\"t\": 1, \"p\": \"src/examples/dbtest/ccdb.json\", \"c\": \"{\\n    \\\"tables\\\": {\\n        \\\"user\\\": \\\"user.json\\\",\\n        \\\"item\\\": \\\"item.json\\\"\\n    },\\n    \\\"login\\\": {\\n        \\\"admin\\\": \\\"adminpass\\\",\\n        \\\"allowed\\\": \\\"allowedpass\\\"\\n    }\\n}\"}, {\"t\": 1, \"p\": \"src/examples/dbtest/item.json\", \"c\": \"{\\n    \\\"schema\\\": {\\n        \\\"current_sysid\\\": 1,\\n        \\\"name\\\": \\\"item\\\",\\n        \\\"indexes\\\": [\\n            {\\n                \\\"field\\\": \\\"id\\\",\\n                \\\"type\\\": \\\"pk\\\"\\n            },\\n            {\\n                \\\"field\\\": \\\"item_id\\\",\\n                \\\"type\\\": \\\"unique\\\"\\n            },\\n            {\\n                \\\"field\\\": \\\"id\\\",\\n                \\\"type\\\": \\\"ai\\\",\\n                \\\"start\\\": 1,\\n                \\\"current\\\": 1\\n            }\\n        ],\\n        \\\"fields\\\": {\\n            \\\"id\\\": {\\n                \\\"type\\\": [\\n                    \\\"integer\\\"\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"item_id\\\": {\\n                \\\"type\\\": [\\n                    \\\"varchar\\\",\\n                    50\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"item_count\\\": {\\n                \\\"type\\\": [\\n                    \\\"integer\\\"\\n                ],\\n                \\\"nullable\\\": true,\\n                \\\"default\\\": 0\\n            }\\n        }\\n    },\\n    \\\"data\\\": []\\n}\"}, {\"t\": 1, \"p\": \"src/examples/dbtest/user.json\", \"c\": \"{\\n    \\\"schema\\\": {\\n        \\\"current_sysid\\\": 3,\\n        \\\"name\\\": \\\"user\\\",\\n        \\\"indexes\\\": [\\n            {\\n                \\\"field\\\": \\\"id\\\",\\n                \\\"type\\\": \\\"pk\\\"\\n            },\\n            {\\n                \\\"field\\\": \\\"username\\\",\\n                \\\"type\\\": \\\"unique\\\"\\n            },\\n            {\\n                \\\"field\\\": \\\"id\\\",\\n                \\\"type\\\": \\\"ai\\\",\\n                \\\"start\\\": 1,\\n                \\\"current\\\": 3\\n            }\\n        ],\\n        \\\"fields\\\": {\\n            \\\"id\\\": {\\n                \\\"type\\\": [\\n                    \\\"integer\\\"\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"username\\\": {\\n                \\\"type\\\": [\\n                    \\\"varchar\\\",\\n                    20\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"email\\\": {\\n                \\\"type\\\": [\\n                    \\\"varchar\\\",\\n                    50\\n                ],\\n                \\\"nullable\\\": false,\\n                \\\"default\\\": null\\n            },\\n            \\\"age\\\": {\\n                \\\"type\\\": [\\n                    \\\"integer\\\"\\n                ],\\n                \\\"nullable\\\": true,\\n                \\\"default\\\": null\\n            }\\n        }\\n    },\\n    \\\"data\\\": [\\n        {\\n            \\\"?sysid?\\\": 1,\\n            \\\"id\\\": 1,\\n            \\\"username\\\": \\\"alice\\\",\\n            \\\"email\\\": \\\"alice@example.com\\\",\\n            \\\"age\\\": 30\\n        },\\n        {\\n            \\\"?sysid?\\\": 2,\\n            \\\"id\\\": 2,\\n            \\\"username\\\": \\\"Jean-Luc\\\",\\n            \\\"email\\\": \\\"jeanluc@example.com\\\",\\n            \\\"age\\\": 45\\n        }\\n    ]\\n}\"}, {\"t\": 2, \"p\": \"src/fs\"}, {\"t\": 1, \"p\": \"src/fs/dbmgr.lua\", \"c\": \"local errmgr = require(\\\"src.core.errmgr\\\")\\n\\n\\nlocal dbmgr = {}\\n\\nlocal base_path = nil\\n\\nfunction dbmgr.opendb(path)\\n    if not string.find(path, \\\"[%a_]+\\\") then\\n        errmgr.error(\\\"Invalid database name: '\\\" .. path)\\n        return nil\\n    end\\n    if not base_path and fs.exists(\\\"cfg/dblocation.cfg\\\") then\\n        local f = fs.open(\\\"cfg/dblocation.cfg\\\", \\\"r\\\")\\n        base_path = f.readAll()\\n        f.close()\\n        path = fs.combine(base_path, path)\\n    elseif not fs.exists(\\\"cfg/dblocation.cfg\\\") and not base_path then\\n        base_path = \\\"src/examples/\\\"\\n        path = fs.combine(base_path, path)\\n    else\\n        path = fs.combine(base_path, path)\\n    end\\n    local db = {}\\n    if not fs.exists(fs.combine(path, \\\"ccdb.json\\\")) then\\n        errmgr.error(\\\"Database path '\\\" .. path .. \\\"' does not exist.\\\")\\n        return nil\\n    end\\n    f = fs.open(fs.combine(path, \\\"ccdb.json\\\"), \\\"r\\\")\\n    db.settings = textutils.unserialiseJSON(f.readAll())\\n    db.path = path\\n    f.close()\\n    db.tables = db.settings.tables or {}\\n    db.login = db.settings.login or {}\\n    function db.opentable(table_name)\\n        if not db.tables[table_name] then\\n            errmgr.error(\\\"Table \\\" .. table_name .. \\\" does not exist in database.\\\")\\n            return nil\\n        end\\n        f = fs.open(fs.combine(db.path, db.tables[table_name]), \\\"r\\\")\\n        local table = textutils.unserialiseJSON(f.readAll())\\n        f.close()\\n        if #table.data == 0 then\\n            table.data = {} -- Else we have \\\"attempt to mutate textutils.empty_json_array\\\"\\n        end\\n        return table\\n    end\\n\\n    function db.auth(login, password)\\n        if db.login[login] and db.login[login] == password then\\n            return true\\n        else\\n            return false\\n        end\\n    end\\n\\n    function db.savetable(table_name, table)\\n        local waited = 0\\n        while fs.exists(fs.combine(db.path, db.tables[table_name]) .. \\\".lock\\\") == true and waited < 100 do\\n            sleep(0.1)\\n            waited = waited + 1\\n        end\\n\\n        if waited >= 100 then\\n            errmgr.error(\\\"Could not acquire lock for table \\\" .. table_name .. \\\".\\\")\\n            return nil\\n        end\\n\\n        f = fs.open(fs.combine(db.path, db.tables[table_name]) .. \\\".lock\\\", \\\"w\\\")\\n        f.write(\\\"lock\\\")\\n        f.close()\\n\\n        if not db.tables[table_name] then\\n            errmgr.error(\\\"Table \\\" .. table_name .. \\\" does not exist in database.\\\")\\n            return nil\\n        end\\n        f = fs.open(fs.combine(db.path, db.tables[table_name]), \\\"w\\\")\\n        f.write(textutils.serialiseJSON(table))\\n        f.close()\\n\\n        fs.delete(fs.combine(db.path, db.tables[table_name]) .. \\\".lock\\\")\\n        return true\\n    end\\n\\n    return db\\nend\\n\\nreturn dbmgr\\n\"}, {\"t\": 1, \"p\": \"src/globals.lua\", \"c\": \"local buildnumber_file = fs.open(\\\"src/.buildnumber\\\", \\\"r\\\")\\nlocal buildnumber = buildnumber_file.readAll()\\nbuildnumber_file.close()\\n\\nlocal globals = {\\n    VERSION = \\\"V0.1.0\\\",\\n    BUILD = buildnumber\\n}\\n\\nreturn globals\\n\"}, {\"t\": 1, \"p\": \"src/main.lua\", \"c\": \"local stdinmgr = require(\\\"src.stdinmgr\\\")\\nlocal rednet_mod = require(\\\"src.utils.rednet\\\")\\nlocal netmgr = require(\\\"src.netmgr\\\")\\n\\nlocal rednet_module_loc = \\\"\\\"\\n\\nif fs.exists(\\\"cfg/rednet_module\\\") then\\n    local f = fs.open(\\\"cfg/rednet_module\\\", \\\"r\\\")\\n    rednet_module_loc = f.readLine()\\n    f.close()\\nelse\\n    rednet_module_loc = \\\"top\\\"\\n    print(\\\"No rednet module configured, defaulting to '\\\" .. rednet_module_loc .. \\\"'\\\")\\n    local f = fs.open(\\\"cfg/rednet_module\\\", \\\"w\\\")\\n    f.writeLine(rednet_module_loc)\\n    f.close()\\nend\\n\\nrednet_mod.rednet_setup(rednet_module_loc)\\n\\n\\nrednet_mod.server(\\n    netmgr.get_conn,\\n    stdinmgr.wait_and_run\\n)\\n\\n-- stop = false\\n\\n-- while not stop do\\n--     io.write(\\\"ccdb> \\\")\\n--     line = io.read(\\\"l\\\")\\n--     stop = stdinmgr.wait_and_run(line)\\n-- end\\n\"}, {\"t\": 1, \"p\": \"src/netmgr.lua\", \"c\": \"local runner = require(\\\"src.core.run\\\")\\nlocal dbmgr = require(\\\"src.fs.dbmgr\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal connections = {}\\n\\nlocal netmgr = {}\\n\\nfunction netmgr.cleanup_old()\\n    for conn_id, data in pairs(connections) do\\n        if os.time() - data.start_time > 120 then -- 2 minutes timeout\\n            connections[conn_id] = nil\\n        end\\n    end\\nend\\n\\nfunction netmgr.get_conn(obj)\\n    netmgr.cleanup_old() -- Clean up old connections\\n    -- Sample message: { type = \\\"init\\\", dbname = \\\"mydb\\\", username = \\\"user\\\", password = \\\"pass\\\" }\\n    if obj.type and obj.type == \\\"init\\\" then\\n        local conn_id = math.random(0, 2147483647)\\n        local db = dbmgr.opendb(obj.dbname)\\n        local username = obj.username\\n        local password = obj.password\\n        if db == nil then\\n            return { type = \\\"error\\\", message = \\\"Failed to open database '\\\" .. obj.dbname .. \\\"'.\\\" }\\n        end\\n        if db.auth(username, password) == false then\\n            return { type = \\\"error\\\", message = \\\"Authentication failed for database '\\\" .. obj.dbname .. \\\"'.\\\" }\\n        end\\n        connections[conn_id] = { db = db, start_time = os.time() }\\n        return { type = \\\"init\\\", conn_id = conn_id }\\n    end\\n    if obj.conn_id == nil then\\n        return { type = \\\"error\\\", message = \\\"No connection ID provided.\\\" }\\n    end\\n    local data = connections[obj.conn_id]\\n    if data == nil then\\n        return { type = \\\"error\\\", message = \\\"Invalid connection ID.\\\" }\\n    end\\n    data.start_time = os.time() -- Refresh connection time\\n    local db = data.db\\n    if obj.type and obj.type == \\\"query\\\" then\\n        local success, result = pcall(runner.run, obj.query, db)\\n        if success then\\n            return { type = \\\"result\\\", result = result }\\n        else\\n            return { type = \\\"error\\\", error = errmgr.generate_report(result) }\\n        end\\n    end\\nend\\n\\nreturn netmgr\\n\"}, {\"t\": 2, \"p\": \"src/parser\"}, {\"t\": 1, \"p\": \"src/parser/parser.lua\", \"c\": \"local strutils = require(\\\"src.utils.strutils\\\")\\nlocal parser_globals = require(\\\"src.parser.parse_globals\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal parser = {}\\nfunction parser.analyze_value(value, noerrors)\\n    if value == \\\"NULL\\\" then\\n        return parser_globals.NULL\\n    end\\n    for name, pattern in pairs(parser_globals.VALUE_TYPES) do\\n        local _, _, captured = string.find(value, pattern)\\n        if captured then\\n            if name == \\\"STRING\\\" then\\n                return captured\\n            elseif name == \\\"FLOAT\\\" then\\n                return tonumber(captured)\\n            elseif name == \\\"INTEGER\\\" then\\n                return tonumber(captured)\\n            elseif name == \\\"BOOLEAN_TRUE\\\" then\\n                return true\\n            elseif name == \\\"BOOLEAN_FALSE\\\" then\\n                return false\\n            elseif name == \\\"CALC\\\" then\\n                return {\\n                    type = \\\"calculation\\\",\\n                    value = captured\\n                }\\n            end\\n        end\\n    end\\n    if not noerrors then\\n        errmgr.error(\\\"Unable to analyze value: \\\" .. value)\\n    end\\n    return nil\\nend\\n\\nfunction parser.where(query)\\n    local where_clause = string.match(strutils.str_trim(query), parser_globals.WHERE)\\n    if where_clause then\\n        local where_conditions = strutils.split_on_separators(where_clause, { \\\"AND\\\", \\\"OR\\\" }, true)\\n        local conditions = {}\\n        for k, where_condition in pairs(where_conditions) do\\n            local condition = strutils.str_trim(where_condition)\\n            local condition_type = nil\\n            if string.sub(condition, 1, 3) == \\\"AND\\\" then\\n                condition_type = \\\"AND\\\"\\n                condition = string.sub(condition, 4)\\n            elseif string.sub(condition, 1, 2) == \\\"OR\\\" then\\n                condition_type = \\\"OR\\\"\\n                condition = string.sub(condition, 3)\\n            end\\n            condition = strutils.str_trim(condition)\\n            _, _, col, operator, value = string.find(condition, parser_globals.WHERE_PATTERN)\\n            if col and operator and value then\\n                value = parser.analyze_value(strutils.str_trim(value), false)\\n                if not value then\\n                    errmgr.error(\\\"Unable to analyze value in WHERE condition: \\\" .. condition)\\n                    return nil\\n                end\\n                conditions[k] = {\\n                    type = condition_type,\\n                    column = col,\\n                    operator = operator,\\n                    value = value\\n                }\\n            else\\n                errmgr.error(\\\"Invalid WHERE condition: \\\" .. condition)\\n                return nil\\n            end\\n        end\\n        return conditions\\n    end\\n    return {}\\nend\\n\\nfunction parser.end_section(query_end)\\n    local limit_number = nil\\n    local collumns = {}\\n    local trimmed_end = strutils.str_trim(query_end)\\n    if trimmed_end == \\\"\\\" then\\n        return {\\n            order_by = collumns,\\n            limit = limit_number\\n        }\\n    end\\n    trimmed_end = strutils.strsplit(trimmed_end, \\\"LIMIT\\\")[1] -- Remove LIMIT part if present\\n    local _, _, orders = string.find(trimmed_end, parser_globals.SELECT_ORDER_BY)\\n    if orders then\\n        local order_columns = strutils.strsplit(strutils.str_trim(orders), \\\",\\\")\\n        for k, col in pairs(order_columns) do\\n            local column = strutils.str_trim(col)\\n            local _, _, col_name, order = string.find(column, parser_globals.SELECT_ORDER_BY_SINGLE)\\n            if col_name and order then\\n                if order == \\\"\\\" then\\n                    order = \\\"ASC\\\"\\n                else\\n                    if order ~= \\\"ASC\\\" and order ~= \\\"DESC\\\" and order ~= \\\"\\\" then\\n                        errmgr.error(\\\"Invalid ORDER BY order: \\\" .. order)\\n                        return nil\\n                    end\\n                    if order == \\\"\\\" then\\n                        order = \\\"ASC\\\"\\n                    end\\n                end\\n\\n                collumns[k] = {\\n                    column = col_name,\\n                    order = order\\n                }\\n            else\\n                errmgr.error(\\\"Invalid ORDER BY part: \\\" .. column)\\n            end\\n        end\\n    end\\n    local _, _, limit = string.find(strutils.str_trim(query_end), parser_globals.SELECT_LIMIT)\\n    if limit then\\n        limit_number = tonumber(strutils.str_trim(limit))\\n        if not limit_number then\\n            errmgr.error(\\\"Invalid LIMIT number: \\\" .. limit)\\n            return nil\\n        end\\n    end\\n    return {\\n        order_by = collumns,\\n        limit = limit_number\\n    }\\nend\\n\\nfunction parser.parse_select(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*$\\\", \\\"\\\")\\n    _, _, indexes, sqltable = string.find(query_filtred, parser_globals.SELECT_FROM)\\n    if indexes and sqltable then\\n        indexes_clean = indexes\\n        returned = {\\n            type = \\\"select\\\",\\n            data = {},\\n            from = sqltable\\n        }\\n        if indexes_clean == \\\"*\\\" then\\n            indexes_clean = \\\"\\\"\\n            returned[\\\"data\\\"][\\\"return_cols_all\\\"] = true\\n        else\\n            local indexes = strutils.split_on_single_char(indexes_clean, \\\",\\\")\\n            local cleaned_indexes = {}\\n            for k, col in pairs(indexes) do\\n                if string.find(strutils.str_trim(col), parser_globals.COLUMN_NAME) then\\n                    cleaned_indexes[k] = {\\n                        type = \\\"column\\\",\\n                        value = strutils.str_trim(col)\\n                    }\\n                else\\n                    index = parser.analyze_value(strutils.str_trim(col), true)\\n                    if index == nil then\\n                        errmgr.error(\\\"Unable to analyze SELECT index: \\\" .. col)\\n                        return nil\\n                    else\\n                        cleaned_indexes[k] = index\\n                    end\\n                end\\n            end\\n            returned[\\\"data\\\"][\\\"return_cols\\\"] = cleaned_indexes\\n        end\\n    else\\n        errmgr.error(\\\"Unable to parse SELECT indexes and FROM table.\\\")\\n        return nil\\n    end\\n    local query_cleaned = query_filtred:gsub(parser_globals.SELECT_FROM_ONLY, \\\"\\\"):gsub(\\\";$\\\", \\\"\\\"); -- Remove processed parts and semicolon\\n    if query_cleaned == \\\"\\\" then\\n        returned[\\\"data\\\"][\\\"where\\\"] = {}\\n        returned[\\\"data\\\"][\\\"limit\\\"] = nil\\n        return returned\\n    end\\n    local where_clause = strutils.split_on_separators(query_cleaned, { \\\"ORDER\\\", \\\"LIMIT\\\" }, false)[1]; -- Remove end section if present\\n    if string.find(where_clause, parser_globals.WHERE) ~= nil then\\n        local where_parsed = parser.where(where_clause)\\n        if not where_parsed then\\n            errmgr.error(\\\"Unable to parse WHERE clause.\\\")\\n            return nil\\n        end\\n        returned[\\\"data\\\"][\\\"where\\\"] = where_parsed\\n    else\\n        returned[\\\"data\\\"][\\\"where\\\"] = {}\\n    end\\n    query_cleaned = strutils.safe_replace(query_cleaned, where_clause, \\\"\\\"):gsub(\\\";$\\\", \\\"\\\"); -- Remove processed WHERE part and semicolon\\n    query_cleaned = strutils.str_trim(query_cleaned)\\n    local ending_parsed = parser.end_section(query_cleaned)\\n    if not ending_parsed then\\n        errmgr.error(\\\"Unable to parse END section.\\\")\\n        return nil\\n    end\\n    returned[\\\"data\\\"][\\\"limit\\\"] = ending_parsed[\\\"limit\\\"]\\n    returned[\\\"data\\\"][\\\"order_by\\\"] = ending_parsed[\\\"order_by\\\"]\\n    return returned\\nend\\n\\nfunction parser.parse_insert(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*;$\\\", \\\"\\\")\\n    _, _, sqltable, columns, values = string.find(query_filtred, parser_globals.INSERT_INTO)\\n    if sqltable and columns and values then\\n        local columns_list_raw = strutils.strsplit(strutils.str_trim(columns), \\\",\\\")\\n        local values_lists_raw = strutils.split_on_single_char(values, \\\")\\\")\\n        local values_lists = {}\\n        for k, value in pairs(values_lists_raw) do\\n            local _, _, cleaned_value = string.find(value, parser_globals.INSERT_CLEANUP)\\n            if cleaned_value then\\n                local value_items_raw = strutils.split_on_single_char(strutils.str_trim(cleaned_value), \\\",\\\")\\n                local value_items = {}\\n                for _, item in pairs(value_items_raw) do\\n                    local analyzed_value = parser.analyze_value(strutils.str_trim(item), false)\\n                    if type(analyzed_value) == \\\"table\\\" and analyzed_value.type == \\\"calculation\\\" then\\n                        errmgr.error(\\\"Calculations are not supported in INSERT values: \\\" .. item)\\n                        return nil\\n                    end\\n                    if analyzed_value == nil then\\n                        errmgr.error(\\\"Unable to analyze value in INSERT: \\\" .. item)\\n                        return nil\\n                    end\\n                    table.insert(value_items, analyzed_value)\\n                end\\n                table.insert(values_lists, value_items)\\n            end\\n        end\\n        for k, col in pairs(columns_list_raw) do\\n            columns_list_raw[k] = strutils.str_trim(col:gsub(\\\"%(*\\\", \\\"\\\"):gsub(\\\"%)*\\\", \\\"\\\"))\\n        end\\n        returned = {\\n            type = \\\"insert\\\",\\n            data = {\\n                columns = columns_list_raw,\\n                values = values_lists\\n            },\\n            from = sqltable\\n        }\\n    end\\n    return returned\\nend\\n\\nfunction parser.parse_update(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*;$\\\", \\\"\\\")\\n    _, _, sqltable, other_parts = string.find(query_filtred, parser_globals.UPDATE)\\n    if sqltable and other_parts then\\n        local query_cleaned = query_filtred:gsub(parser_globals.UPDATE_ONLY, \\\"\\\"):gsub(\\\";$\\\", \\\"\\\")\\n        local parts = strutils.split_on_separators(query_cleaned, { \\\"WHERE\\\" }, false); -- Remove WHERE if present\\n        local set_clause = parts[1]\\n        local set_parts_raw = strutils.split_on_single_char(set_clause, \\\",\\\")\\n        local set_parts = {}\\n        for k, part in pairs(set_parts_raw) do\\n            local _, _, col, value = string.find(strutils.str_trim(part), parser_globals.UPDATE_PART)\\n            if col and value then\\n                local analyzed_value = parser.analyze_value(strutils.str_trim(value), false)\\n                if analyzed_value == nil then\\n                    errmgr.error(\\\"Unable to analyze value in UPDATE SET: \\\" .. value)\\n                    return nil\\n                end\\n                set_parts[k] = {\\n                    column = col,\\n                    value = analyzed_value\\n                }\\n            else\\n                errmgr.error(\\\"Invalid UPDATE SET part: \\\" .. part)\\n                return nil\\n            end\\n        end\\n        if #parts < 2 then\\n            parts[2] = \\\"\\\"\\n        end\\n        local where_clause = parts[2]:gsub(\\\";$\\\", \\\"\\\"); -- Remove semicolon if present\\n        local where_parsed = nil\\n        if where_clause then\\n            where_parsed = parser.where(\\\"WHERE \\\" .. where_clause)\\n            if not where_parsed then\\n                errmgr.error(\\\"Unable to parse WHERE clause in UPDATE.\\\")\\n                return nil\\n            end\\n        end\\n        returned = {\\n            type = \\\"update\\\",\\n            data = {\\n                set = set_parts,\\n                where = where_parsed\\n            },\\n            from = sqltable\\n        }\\n    end\\n    return returned\\nend\\n\\nfunction parser.parse_delete(query)\\n    local returned = {}\\n    local query_filtred = strutils.str_trim(query):gsub(\\\"\\\\n[^\\\\n]*;$\\\", \\\"\\\")\\n    _, _, sqltable, where = string.find(query_filtred, parser_globals.DELETE)\\n    if sqltable and where then\\n        local where_parsed = parser.where(where)\\n        if not where_parsed then\\n            errmgr.error(\\\"Unable to parse WHERE clause in DELETE.\\\")\\n            return nil\\n        end\\n        returned = {\\n            type = \\\"delete\\\",\\n            data = {\\n                where = where_parsed\\n            },\\n            from = sqltable\\n        }\\n    end\\n    return returned\\nend\\n\\nfunction parser.parse(query)\\n    local query_type = string.match(strutils.str_trim(query), parser_globals.QUERY_TYPE)\\n    if query_type == \\\"SELECT\\\" then\\n        return parser.parse_select(query)\\n    elseif query_type == \\\"INSERT\\\" then\\n        return parser.parse_insert(query)\\n    elseif query_type == \\\"UPDATE\\\" then\\n        return parser.parse_update(query)\\n    elseif query_type == \\\"DELETE\\\" then\\n        return parser.parse_delete(query)\\n    else\\n        errmgr.error(\\\"Unknown query type.\\\")\\n        return nil\\n    end\\nend\\n\\nreturn parser\\n\"}, {\"t\": 1, \"p\": \"src/parser/parse_globals.lua\", \"c\": \"-- Patterns\\n\\nlocal parse_globals = {}\\nparse_globals.SELECT_FROM = \\\"^SELECT (.+) FROM ([%a_]+)%s*.*;$\\\"\\nparse_globals.SELECT_FROM_ONLY = \\\"^SELECT ([%a_,*%s*]+) FROM ([%a_]+)%s*\\\"\\nparse_globals.WHERE = \\\"WHERE%s+(.*)%s*\\\"\\nparse_globals.WHERE_PATTERN = \\\"^([%a_]+)%s*([<>!=%%]+)%s*(.*)$\\\"\\nparse_globals.SELECT_ORDER_BY = \\\"ORDER%s+BY%s+([%a_,%s]+)\\\"\\nparse_globals.SELECT_ORDER_BY_SINGLE = \\\"([%a_]+)%s*([%a]*)\\\"; -- check of ASC/DESC will be done in parser\\nparse_globals.SELECT_LIMIT = \\\"LIMIT%s+(%d+)$\\\"\\nparse_globals.INSERT_INTO = \\\"^INSERT%s+INTO%s+([%a_]+)%s*(%([%s%a_,]+%))%s*VALUES%s+(.*);$\\\"\\nparse_globals.INSERT_CLEANUP = \\\"^,?%s*%((.*)$\\\"\\nparse_globals.UPDATE = \\\"^UPDATE%s+([%a_]+)%s+SET%s+(.*);$\\\"\\nparse_globals.UPDATE_ONLY = \\\"^UPDATE%s+([%a_]+)%s+SET%s+\\\"\\nparse_globals.UPDATE_PART = \\\"^([%a_]+)%s*=%s*(.*)\\\"\\nparse_globals.DELETE = \\\"^DELETE%s+FROM%s+([%a_]+)%s*(.*);$\\\"\\nparse_globals.QUERY_TYPE = \\\"^([%a]+)%s\\\"\\nparse_globals.COLUMN_NAME = \\\"^[%a_]+$\\\"\\nparse_globals.VALUE_TYPES = {\\n    STRING = \\\"^'(.*)'$\\\",\\n    FLOAT = \\\"^(%-?%d+%.?%d*)$\\\",\\n    INTEGER = \\\"^(%-?%d+)$\\\",\\n    BOOLEAN_TRUE = \\\"^(TRUE)$\\\",\\n    BOOLEAN_FALSE = \\\"^(FALSE)$\\\",\\n    NULL = \\\"^(NULL)$\\\",\\n    CALC = \\\"^([%a_%^%d%.%+%-%*/%%%s]+)$\\\"\\n}\\n\\nparse_globals.NULL = {\\n    type = \\\"null\\\",\\n    value = nil\\n}; -- Used so we can differentiate between a NULL value and a missing value\\n\\nreturn parse_globals\\n\"}, {\"t\": 1, \"p\": \"src/stdinmgr.lua\", \"c\": \"local runner = require(\\\"src.core.run\\\")\\nlocal dbmgr = require(\\\"src.fs.dbmgr\\\")\\nlocal errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal stdinmgr = {}\\n\\nlocal db = nil\\n\\nfunction stdinmgr.wait_and_run(line)\\n    if line == nil or line == \\\"exit\\\" then\\n        return true\\n    end\\n    _, _, dbname = string.find(line, \\\"OPEN%((.*)%);\\\") -- OPEN(xyz); command\\n    if dbname then\\n        success, dbtemp = pcall(dbmgr.opendb, dbname)\\n        if not success then\\n            print(errmgr.generate_report(dbtemp))\\n            return\\n        end\\n        if dbtemp == nil then\\n            print(\\\"Failed to open database '\\\" .. dbname .. \\\"'.\\\")\\n            return\\n        end\\n        io.write(\\\"Username: \\\")\\n        username = io.read(\\\"l\\\")\\n        io.write(\\\"Password: \\\")\\n        password = io.read(\\\"l\\\")\\n        if dbtemp.auth(username, password) == false then\\n            print(\\\"Authentication failed for database '\\\" .. dbname .. \\\"'.\\\")\\n            return\\n        end\\n        db = dbtemp\\n        print(\\\"Database '\\\" .. dbname .. \\\"' opened.\\\")\\n    else\\n        if db == nil then\\n            print(\\\"No database opened. Use OPEN(dbname); to open a database.\\\")\\n            return\\n        end\\n        local success, result = pcall(runner.run, line, db)\\n\\n        print(\\\"---- RESULT ----\\\")\\n        if success then\\n            if result == nil then\\n                print(\\\"No result.\\\")\\n            else\\n                print(textutils.serialize(result))\\n            end\\n        else\\n            print(errmgr.generate_report(result))\\n        end\\n    end\\nend\\n\\nreturn stdinmgr\\n\"}, {\"t\": 2, \"p\": \"src/utils\"}, {\"t\": 1, \"p\": \"src/utils/rednet.lua\", \"c\": \"local rednet_mod = {}\\n\\nlocal host = nil\\n\\nif fs.exists(\\\"cfg/rednet_host\\\") then\\n    local f = fs.open(\\\"cfg/rednet_host\\\", \\\"r\\\")\\n    host = f.readLine()\\n    f.close()\\nelse\\n    host = \\\"ccdb_server_\\\" .. tostring(math.random(1000, 9999))\\n    print(\\\"Generated rednet host ID: \\\" .. host)\\n    local f = fs.open(\\\"cfg/rednet_host\\\", \\\"w\\\")\\n    f.writeLine(host)\\n    f.close()\\nend\\n\\nrednet_cfg_module = nil\\nfunction rednet_mod.rednet_setup(module_loc)\\n    rednet_cfg_module = module_loc\\n    rednet.open(module_loc)\\n    rednet.host(\\\"ccdb\\\", host)\\nend\\n\\nfunction rednet_mod.safe_json(str)\\n    local success, result = pcall(function() return textutils.unserializeJSON(str) end)\\n    if success then\\n        return result\\n    else\\n        print(\\\"[ERROR]: Failed to parse JSON: \\\" .. tostring(result))\\n        return nil\\n    end\\nend\\n\\nfunction rednet_mod.server(callback, stdin_callback)\\n    if not rednet_cfg_module then\\n        print(\\\"Tried to run a server without rednet_setup() called first\\\")\\n        return\\n    end\\n    local stop = false\\n    local function server_callback_wrapper()\\n        clientid, r = rednet.receive(\\\"ccdb\\\")\\n        obj         = rednet_mod.safe_json(r)\\n        if obj and obj.type and obj.type == \\\"ping\\\" then -- Used to counter the problem if two clients try to connect at once\\n            rednet.send(clientid, textutils.serializeJSON({ type = \\\"pong\\\" }), \\\"ccdb\\\")\\n            return\\n        end\\n        _, res = pcall(callback, obj)\\n        if type(res) ~= \\\"table\\\" then\\n            res = { type = \\\"error\\\", message = res or \\\"Unknown error\\\" }\\n        end\\n        rednet.send(clientid, textutils.serializeJSON(res), \\\"ccdb\\\")\\n    end\\n    local function stdin_callback_wrapper()\\n        io.write(\\\"ccdb> \\\")\\n        local input = io.read(\\\"l\\\")\\n        _, stop = pcall(stdin_callback, input)\\n    end\\n    while not stop do\\n        parallel.waitForAny(server_callback_wrapper, stdin_callback_wrapper)\\n    end\\nend\\n\\nreturn rednet_mod\\n\"}, {\"t\": 1, \"p\": \"src/utils/safecalc.lua\", \"c\": \"local errmgr = require(\\\"src.core.errmgr\\\")\\n\\nlocal safecalc = {}\\n\\nfunction safecalc.safe_calc(expr, kv_table)\\n    local str = expr;\\n    for k, v in pairs(kv_table) do\\n        str = string.gsub(str, k, tostring(v))\\n    end\\n    -- Put space bewteen numbers and operators to avoid concatenation issues\\n    str = string.gsub(str, \\\"([%d%.]+)([%+%-%*/%%])\\\", \\\"%1 %2\\\")\\n    str = string.gsub(str, \\\"([%+%%-%*/%%])([%d%.]+)\\\", \\\"%1 %2\\\")\\n    if string.find(str, \\\"[^%d%.%+%-%*/%% ]\\\") then\\n        errmgr.error(\\\"Unsafe characters detected in expression '\\\" .. expr .. \\\"'.\\\")\\n        return nil\\n    end\\n    local func, err = load(\\\"return \\\" .. str)\\n    if not func then\\n        errmgr.error(\\\"Error compiling expression '\\\" .. expr .. \\\"': \\\" .. err)\\n        return nil\\n    end\\n    local success, result = pcall(func)\\n    if not success then\\n        errmgr.error(\\\"Error evaluating expression '\\\" .. expr .. \\\"': \\\" .. result)\\n        return nil\\n    end\\n    return result\\nend\\n\\nreturn safecalc\\n\"}, {\"t\": 1, \"p\": \"src/utils/strutils.lua\", \"c\": \"-- http://lua-users.org/wiki/StringTrim\\n\\nlocal strutils = {}\\n\\nfunction strutils.str_trim(stri)\\n    return stri:match(\\\"^%s*(.-)%s*$\\\")\\nend\\n\\n-- Source - https://stackoverflow.com/a\\n-- Posted by user973713, modified by community. See post 'Timeline' for change history\\n-- Retrieved 2025-12-12, License - CC BY-SA 4.0\\n\\nfunction strutils.strsplit(inputstr, sep)\\n    if sep == nil then\\n        sep = \\\"%s\\\"\\n    end\\n    local t = {}\\n    for str in string.gmatch(inputstr, \\\"([^\\\" .. sep .. \\\"]+)\\\") do\\n        table.insert(t, str)\\n    end\\n    return t\\nend\\n\\n-- From me\\n-- Safely replaces a pattern in a string by escaping all non-word characters in the pattern\\nfunction strutils.safe_replace(str, pattern, replacement)\\n    local escaped_pattern = pattern:gsub(\\\"(%W)\\\", \\\"%%%1\\\")\\n    return str:gsub(escaped_pattern, replacement)\\nend\\n\\n-- Ik, it's not the best way to do it, but whatever.\\n-- This is not by me. I don't remember where I found it.\\n-- It basically splits a string on multiple separators, ignoring those inside quotes.\\nfunction strutils.split_on_separators(str, seps, keep_seps)\\n    local sep_lookup = {}\\n    for _, s in ipairs(seps) do\\n        sep_lookup[s] = true\\n    end\\n\\n    local result = {}\\n    local current = {}\\n\\n    local in_single = false\\n    local in_double = false\\n\\n    for token in str:gmatch(\\\"%S+\\\") do\\n        for i = 1, #token do\\n            local char = token:sub(i, i)\\n            if char == \\\"'\\\" then in_single = not in_single end\\n            if char == '\\\"' then in_double = not in_double end\\n        end\\n\\n        local inside_quotes = in_single or in_double\\n        if not inside_quotes and sep_lookup[token] then\\n            if keep_seps then\\n                table.insert(result, table.concat(current, \\\" \\\"))\\n                current = {}\\n                table.insert(current, token .. \\\" \\\")\\n            else\\n                table.insert(result, table.concat(current, \\\" \\\"))\\n                current = {}\\n            end\\n        else\\n            table.insert(current, token)\\n        end\\n    end\\n\\n    if #current > 0 then\\n        table.insert(result, table.concat(current, \\\" \\\"))\\n    end\\n\\n    return result\\nend\\n\\nfunction strutils.split_on_single_char(str, char)\\n    local result = {}\\n    local current = {}\\n\\n    local in_single = false\\n    local in_double = false\\n\\n    for k, token in pairs(strutils.totable(str)) do\\n        if token == \\\"'\\\" then in_single = not in_single end\\n        if token == '\\\"' then in_double = not in_double end\\n\\n        local inside_quotes = in_single or in_double\\n\\n        if not inside_quotes and token == char then\\n            table.insert(result, table.concat(current))\\n            current = {}\\n        else\\n            table.insert(current, token)\\n        end\\n    end\\n\\n    if #current > 0 then\\n        table.insert(result, table.concat(current))\\n    end\\n\\n    return result\\nend\\n\\nfunction strutils.totable(str)\\n    local t = {}\\n    str:gsub(\\\".\\\", function(c) table.insert(t, c) end)\\n    return t\\nend\\n\\nreturn strutils\\n\"}, {\"t\": 1, \"p\": \"src/utils/tableutils.lua\", \"c\": \"-- Table utils\\n\\nlocal tableutils = {}\\n\\nfunction tableutils.extend(list, otherlist)\\n    for _, v in ipairs(otherlist) do\\n        table.insert(list, v)\\n    end\\n    return list\\nend\\n\\n-- Source - https://stackoverflow.com/a\\n-- Posted by Chris\\n-- Retrieved 2025-12-12, License - CC BY-SA 3.0\\n\\nfunction tableutils.compare(one, two)\\n    if type(one) == type(two) then\\n        if type(one) == \\\"table\\\" then\\n            if #one == #two then\\n                -- If both types are the same, both are tables and\\n                -- the tables are the same size, recurse through each\\n                -- table entry.\\n                for loop = 1, #one do\\n                    if tableutils.compare(one[loop], two[loop]) == false then\\n                        return false\\n                    end\\n                end\\n\\n                -- All table contents match\\n                return true\\n            end\\n        else\\n            -- Values are not tables but matching types. Compare\\n            -- them and return if they match\\n            return one == two\\n        end\\n    end\\n    return false\\nend\\n\\nreturn tableutils\\n\"}]"

if not is_setup then
    print("[RUNNER]: Starting CCDB...")
    require(root_runtime .. "." .. "main")
    return
end
local files = textutils.unserialiseJSON(JSON)

for key, val in pairs(files) do
    if val["t"] == 2 then
        fs.makeDir(fs.combine(root, val["p"]))
    end
    if val["t"] == 1 then
        local file = fs.open(fs.combine(root, val["p"]), "w")
        print("[SETUP]: Writing to " .. val["p"])
        file.write(val["c"])
        file.close()
    end
end

print("[SETUP]: Setup complete. You can now run CCDB without the 'setup' argument.")